{"version":3,"sources":["webpack:///./src/components/PartAndWhole.tsx","webpack:///./src/components/keypad/Keypad.tsx","webpack:///./src/util/questions.ts","webpack:///./src/pages/index.tsx","webpack:///./src/components/PressToStart.tsx","webpack:///./src/components/Results.tsx","webpack:///./src/components/Title.tsx","webpack:///./src/util/random.ts","webpack:///./node_modules/mousetrap/mousetrap.js"],"names":["Orientation","keyboard","type","number","Keypad","keypadDisabled","enterDisabled","deleteDisabled","onKeyPress","useEffect","Mousetrap","e","parseInt","key","rows","map","keyRow","index","className","disabled","onClick","undefined","characterForKey","orientationFromIndex","Top","Right","Bottom","Left","Blank","Phase","PartAndWhole","orientation","whole","part1","part2","lines","linesForOrientation","wholeCorrectness","part1Correctness","part2Correctness","wholeText","length","part1Text","part2Text","width","height","x1","y1","x2","y2","stroke","strokeWidth","PressToStart","onPress","level","Results","results","outOf","onPlayAgainPressed","score","reduce","acc","cur","Title","randomInt","between","and","Math","floor","random","generateQuestion","max","previousQuestion","blank","diceRoll","Whole","Part1","Part2","LEVELS","Game","useState","WaitingToStart","phase","setPhase","setLevel","setResults","currentQuestion","setCurrentQuestion","currentGuess","setCurrentGuess","showingFeedback","setShowingFeedback","maxAnswerDigits","processGuess","expected","question","expectedAnswerForQuestion","answerCorrect","questionsAnswered","setTimeout","InProgress","slice","window","document","_REVERSE_MAP","_MAP","8","9","13","16","17","18","20","27","32","33","34","35","36","37","38","39","40","45","46","91","93","224","_KEYCODE_MAP","106","107","109","110","111","186","187","188","189","190","191","192","219","220","221","222","_SHIFT_MAP","_SPECIAL_ALIASES","test","navigator","platform","i","toString","prototype","bind","keys","callback","action","Array","this","_bindMultiple","call","unbind","trigger","_directMap","reset","_callbacks","stopCallback","element","indexOf","_belongsTo","ancestor","parentNode","target","composedPath","initialEventTarget","tagName","isContentEditable","handleKey","self","_handleKey","apply","arguments","addKeycodes","object","hasOwnProperty","init","documentMousetrap","method","charAt","module","exports","_addEvent","addEventListener","attachEvent","_characterFromEvent","character","String","fromCharCode","which","shiftKey","toLowerCase","_isModifier","_pickBestAction","modifiers","_getReverseMap","_getKeyInfo","combination","replace","split","_keysFromString","push","targetElement","_resetTimer","_sequenceLevels","_ignoreNextKeyup","_ignoreNextKeypress","_nextExpectedAction","_resetSequences","doNotReset","activeSequences","_getMatches","sequenceName","modifiers1","modifiers2","matches","seq","metaKey","ctrlKey","sort","join","deleteCombo","combo","deleteSequence","splice","_fireCallback","sequence","srcElement","preventDefault","returnValue","_preventDefault","stopPropagation","cancelBubble","_stopPropagation","_handleKeyEvent","keyCode","altKey","_eventModifiers","_bindSequence","_increaseSequence","nextAction","clearTimeout","_callbackAndReset","wrappedCallback","_bindSingle","info","callbacks","maxLevel","processedSequenceCallback","ignoreThisKeypress","combinations"],"mappings":"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","file":"component---src-pages-index-tsx-bb6e88a59f3c069a1d40.js","sourcesContent":["import React from 'react';\n\nexport enum Orientation {\n  Top = 'top',\n  Right = 'right',\n  Bottom = 'bottom',\n  Left = 'left',\n}\n\nexport function orientationFromIndex(index: number) {\n  switch (index) {\n    case 0:\n    default:\n      return Orientation.Top;\n    case 1:\n      return Orientation.Right;\n    case 2:\n      return Orientation.Bottom;\n    case 3:\n      return Orientation.Left;\n  }\n}\n\nconst linesForOrientation = (orientation: Orientation) => {\n  switch (orientation) {\n    case Orientation.Top:\n      return [\n        [200, 50, 50, 250],\n        [200, 50, 350, 250],\n      ];\n    case Orientation.Right:\n      return [\n        [50, 50, 350, 150],\n        [50, 250, 350, 150],\n      ];\n    case Orientation.Bottom:\n      return [\n        [50, 50, 200, 250],\n        [350, 50, 200, 250],\n      ];\n    case Orientation.Left:\n      return [\n        [50, 150, 350, 50],\n        [50, 150, 350, 250],\n      ];\n  }\n};\n\nexport default function PartAndWhole({\n  orientation,\n  whole,\n  part1,\n  part2,\n}: {\n  orientation: Orientation;\n  whole: string;\n  part1: string;\n  part2: string;\n}) {\n  const lines = linesForOrientation(orientation);\n\n  const wholeCorrectness =\n    whole === 'correct' ? 'correct' : whole === 'incorrect' ? 'incorrect' : '';\n  const part1Correctness =\n    part1 === 'correct' ? 'correct' : part1 === 'incorrect' ? 'incorrect' : '';\n  const part2Correctness =\n    part2 === 'correct' ? 'correct' : part2 === 'incorrect' ? 'incorrect' : '';\n\n  const wholeText = wholeCorrectness.length ? '' : whole;\n  const part1Text = part1Correctness.length ? '' : part1;\n  const part2Text = part2Correctness.length ? '' : part2;\n\n  return (\n    <div className=\"part-whole-container\">\n      <div\n        className={`part-whole-box whole ${orientation} ${wholeCorrectness}`}\n      >\n        {wholeText}\n      </div>\n      <div\n        className={`part-whole-box part1 ${orientation} ${part1Correctness}`}\n      >\n        {part1Text}\n      </div>\n      <div\n        className={`part-whole-box part2 ${orientation} ${part2Correctness}`}\n      >\n        {part2Text}\n      </div>\n\n      <svg width=\"400\" height=\"300\">\n        <line\n          x1={lines[0][0]}\n          y1={lines[0][1]}\n          x2={lines[0][2]}\n          y2={lines[0][3]}\n          stroke=\"black\"\n          strokeWidth=\"5\"\n        />\n        <line\n          x1={lines[1][0]}\n          y1={lines[1][1]}\n          x2={lines[1][2]}\n          y2={lines[1][3]}\n          stroke=\"black\"\n          strokeWidth=\"5\"\n        />\n      </svg>\n    </div>\n  );\n}\n","import * as Mousetrap from 'mousetrap';\nimport React, { useEffect } from 'react';\n\ntype Key = NumberKey | { type: 'delete' } | { type: 'enter' };\n\ninterface NumberKey {\n  type: 'number';\n  number: number;\n}\n\nconst characterForKey = (key: Key) => {\n  switch (key.type) {\n    case 'delete':\n      return '←';\n    case 'enter':\n      return '✓';\n    case 'number':\n      return `${key.number}`;\n  }\n};\n\nconst keyboard: Key[][] = [\n  [\n    { type: 'number', number: 1 },\n    { type: 'number', number: 2 },\n    { type: 'number', number: 3 },\n    { type: 'number', number: 4 },\n    { type: 'number', number: 5 },\n    { type: 'delete' },\n  ],\n  [\n    { type: 'number', number: 6 },\n    { type: 'number', number: 7 },\n    { type: 'number', number: 8 },\n    { type: 'number', number: 9 },\n    { type: 'number', number: 0 },\n    { type: 'enter' },\n  ],\n];\n\nexport default function Keypad({\n  keypadDisabled,\n  enterDisabled,\n  deleteDisabled,\n  onKeyPress,\n}: {\n  keypadDisabled: boolean;\n  enterDisabled: boolean;\n  deleteDisabled: boolean;\n  onKeyPress: (key: Key) => void;\n}) {\n  useEffect(() => {\n    Mousetrap.bind(['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'], (e) => {\n      if (!keypadDisabled) {\n        onKeyPress({ type: 'number', number: parseInt(e.key) });\n      }\n    });\n\n    Mousetrap.bind(['backspace'], () => {\n      if (!keypadDisabled && !deleteDisabled) {\n        onKeyPress({ type: 'delete' });\n      }\n    });\n\n    Mousetrap.bind(['enter'], () => {\n      if (!keypadDisabled && !enterDisabled) {\n        onKeyPress({ type: 'enter' });\n      }\n    });\n\n    return () => {\n      Mousetrap.reset();\n    };\n  }, [keypadDisabled, enterDisabled, deleteDisabled, onKeyPress]);\n\n  const rows = keyboard.map((keyRow, index) => {\n    return (\n      <div key={index} className=\"keypad-row\">\n        {keyRow.map((key, index) => {\n          const disabled =\n            keypadDisabled ||\n            (key.type === 'enter' && enterDisabled) ||\n            (key.type === 'delete' && deleteDisabled);\n          return (\n            <div\n              key={index}\n              className={`button keypad-key ${key.type} ${\n                disabled ? 'disabled' : ''\n              }`}\n              onClick={!disabled ? () => onKeyPress(key) : undefined}\n            >\n              {characterForKey(key)}\n            </div>\n          );\n        })}\n      </div>\n    );\n  });\n\n  return <div className=\"keypad-container\">{rows}</div>;\n}\n","import {\n  Orientation as PartAndWholeOrientation,\n  orientationFromIndex,\n} from '@/components/PartAndWhole';\nimport { randomInt } from './random';\n\nexport enum Blank {\n  Whole,\n  Part1,\n  Part2,\n}\n\nexport interface Question {\n  orientation: PartAndWholeOrientation;\n  blank: Blank;\n  whole: number;\n  part1: number;\n  part2: number;\n}\n\nexport function expectedAnswerForQuestion(question: Question): number {\n  switch (question.blank) {\n    case Blank.Whole:\n      return question.whole;\n    case Blank.Part1:\n      return question.part1;\n    case Blank.Part2:\n      return question.part2;\n  }\n}\n\nexport function generateQuestion(\n  max: number,\n  previousQuestion?: Question,\n): Question {\n  const orientation = (() => {\n    let orientation: PartAndWholeOrientation;\n    while (true) {\n      orientation = orientationFromIndex(randomInt(0, 3));\n      if (!previousQuestion || orientation !== previousQuestion.orientation) {\n        break;\n      }\n    }\n\n    return orientation;\n  })();\n\n  const blank = (() => {\n    let blank: Blank;\n    while (true) {\n      const diceRoll = randomInt(0, 2);\n      blank =\n        diceRoll === 0\n          ? Blank.Whole\n          : diceRoll === 1\n          ? Blank.Part1\n          : Blank.Part2;\n      if (!previousQuestion || blank !== previousQuestion.blank) {\n        break;\n      }\n    }\n\n    return blank;\n  })();\n\n  const whole = randomInt(1, max);\n  const part1 = randomInt(0, whole);\n  const part2 = whole - part1;\n\n  return { orientation, blank, whole, part1, part2 };\n}\n","import Keypad from '@/components/keypad/Keypad';\nimport PartAndWhole from '@/components/PartAndWhole';\nimport PressToStart from '@/components/PressToStart';\nimport Results from '@/components/Results';\nimport Title from '@/components/Title';\nimport {\n  Blank,\n  expectedAnswerForQuestion,\n  generateQuestion,\n  Question,\n} from '@/util/questions';\nimport React, { useState } from 'react';\n\nenum Phase {\n  WaitingToStart,\n  InProgress,\n  Results,\n}\n\nconst LEVELS = [9, 20, 99];\n\nconst QUESTIONS_PER_ROUND = 10;\nconst RESULT_FEEDBACK_MS = 2000;\n\nexport default function Game() {\n  const [phase, setPhase] = useState(Phase.WaitingToStart);\n  const [level, setLevel] = useState<0 | 1 | 2>(2);\n  const [results, setResults] = useState<boolean[]>([]);\n  const [currentQuestion, setCurrentQuestion] = useState<Question | undefined>(\n    undefined,\n  );\n  const [currentGuess, setCurrentGuess] = useState('');\n  const [showingFeedback, setShowingFeedback] = useState(false);\n\n  const maxAnswerDigits = `${LEVELS[level]}`.length;\n\n  function reset() {\n    setPhase(Phase.WaitingToStart);\n    setLevel(0);\n    setResults([]);\n    setCurrentQuestion(undefined);\n    setCurrentGuess('');\n  }\n\n  function processGuess() {\n    const expected = expectedAnswerForQuestion(currentQuestion);\n    const answerCorrect = currentGuess === `${expected}`;\n    const questionsAnswered = results.length + 1;\n\n    setResults([...results, answerCorrect]);\n    setShowingFeedback(true);\n    setCurrentGuess(answerCorrect ? 'correct' : 'incorrect');\n\n    setTimeout(() => {\n      if (questionsAnswered < QUESTIONS_PER_ROUND) {\n        setCurrentGuess('');\n        setCurrentQuestion(generateQuestion(LEVELS[level], currentQuestion));\n      } else {\n        setPhase(Phase.Results);\n      }\n\n      setShowingFeedback(false);\n    }, RESULT_FEEDBACK_MS);\n  }\n\n  return (\n    <main>\n      <Title />\n\n      {phase === Phase.WaitingToStart && (\n        <PressToStart\n          onPress={(level) => {\n            setLevel(level);\n            setCurrentQuestion(generateQuestion(LEVELS[level], undefined));\n            setPhase(Phase.InProgress);\n          }}\n        />\n      )}\n\n      {phase === Phase.InProgress && currentQuestion && (\n        <>\n          <PartAndWhole\n            orientation={currentQuestion.orientation}\n            whole={\n              currentQuestion.blank === Blank.Whole\n                ? currentGuess\n                : `${currentQuestion.whole}`\n            }\n            part1={\n              currentQuestion.blank === Blank.Part1\n                ? currentGuess\n                : `${currentQuestion.part1}`\n            }\n            part2={\n              currentQuestion.blank === Blank.Part2\n                ? currentGuess\n                : `${currentQuestion.part2}`\n            }\n          />\n\n          <Keypad\n            keypadDisabled={showingFeedback}\n            deleteDisabled={currentGuess.length === 0}\n            enterDisabled={currentGuess.length === 0}\n            onKeyPress={(key) => {\n              switch (key.type) {\n                case 'number': {\n                  if (\n                    currentGuess.length < maxAnswerDigits &&\n                    currentGuess !== '0'\n                  ) {\n                    setCurrentGuess(`${currentGuess}${key.number}`);\n                  }\n                  break;\n                }\n                case 'delete': {\n                  if (currentGuess.length > 0) {\n                    setCurrentGuess(\n                      currentGuess.slice(0, currentGuess.length - 1),\n                    );\n                  }\n                  break;\n                }\n                case 'enter': {\n                  if (currentGuess.length > 0) {\n                    processGuess();\n                  }\n                  break;\n                }\n              }\n            }}\n          />\n        </>\n      )}\n\n      {phase === Phase.Results && (\n        <Results\n          results={results}\n          outOf={QUESTIONS_PER_ROUND}\n          onPlayAgainPressed={reset}\n        />\n      )}\n    </main>\n  );\n}\n","import React from 'react';\n\nexport default function PressToStart({\n  onPress,\n}: {\n  onPress: (level: 0 | 1 | 2) => void;\n}) {\n  return (\n    <div className=\"press-to-start-container\">\n      {[0, 1, 2].map((level: 0 | 1 | 2) => (\n        <div\n          key={level}\n          className=\"button press-to-start-button\"\n          onClick={() => {\n            onPress(level);\n          }}\n        >\n          Level {level + 1}\n        </div>\n      ))}\n    </div>\n  );\n}\n","import React from 'react';\n\nexport default function Results({\n  results,\n  outOf,\n  onPlayAgainPressed,\n}: {\n  results: boolean[];\n  outOf: number;\n  onPlayAgainPressed: () => void;\n}) {\n  const score = results.reduce((acc, cur) => acc + (cur ? 1 : 0), 0);\n\n  return (\n    <div className=\"results-container\">\n      <div className=\"results-score\">\n        You scored <span className=\"numeral\">{score}</span> out of{' '}\n        <span className=\"numeral\">{outOf}</span>\n      </div>\n      <div className=\"button results-play-again\" onClick={onPlayAgainPressed}>\n        Play Again\n      </div>\n    </div>\n  );\n}\n","import React from 'react';\n\nexport default function Title() {\n  return <h1>Parts & Wholes</h1>;\n}\n","export function randomInt(between: number, and: number) {\n  return Math.floor(Math.random() * (and - between) + between);\n}\n","/*global define:false */\n\n/**\n * Copyright 2012-2017 Craig Campbell\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * Mousetrap is a simple keyboard shortcut library for Javascript with\n * no external dependencies\n *\n * @version 1.6.5\n * @url craig.is/killing/mice\n */\n(function (window, document, undefined) {\n  // Check if mousetrap is used inside browser, if not, return\n  if (!window) {\n    return;\n  }\n  /**\n   * mapping of special keycodes to their corresponding keys\n   *\n   * everything in this dictionary cannot use keypress events\n   * so it has to be here to map to the correct keycodes for\n   * keyup/keydown events\n   *\n   * @type {Object}\n   */\n\n\n  var _MAP = {\n    8: 'backspace',\n    9: 'tab',\n    13: 'enter',\n    16: 'shift',\n    17: 'ctrl',\n    18: 'alt',\n    20: 'capslock',\n    27: 'esc',\n    32: 'space',\n    33: 'pageup',\n    34: 'pagedown',\n    35: 'end',\n    36: 'home',\n    37: 'left',\n    38: 'up',\n    39: 'right',\n    40: 'down',\n    45: 'ins',\n    46: 'del',\n    91: 'meta',\n    93: 'meta',\n    224: 'meta'\n  };\n  /**\n   * mapping for special characters so they can support\n   *\n   * this dictionary is only used incase you want to bind a\n   * keyup or keydown event to one of these keys\n   *\n   * @type {Object}\n   */\n\n  var _KEYCODE_MAP = {\n    106: '*',\n    107: '+',\n    109: '-',\n    110: '.',\n    111: '/',\n    186: ';',\n    187: '=',\n    188: ',',\n    189: '-',\n    190: '.',\n    191: '/',\n    192: '`',\n    219: '[',\n    220: '\\\\',\n    221: ']',\n    222: '\\''\n  };\n  /**\n   * this is a mapping of keys that require shift on a US keypad\n   * back to the non shift equivelents\n   *\n   * this is so you can use keyup events with these keys\n   *\n   * note that this will only work reliably on US keyboards\n   *\n   * @type {Object}\n   */\n\n  var _SHIFT_MAP = {\n    '~': '`',\n    '!': '1',\n    '@': '2',\n    '#': '3',\n    '$': '4',\n    '%': '5',\n    '^': '6',\n    '&': '7',\n    '*': '8',\n    '(': '9',\n    ')': '0',\n    '_': '-',\n    '+': '=',\n    ':': ';',\n    '\\\"': '\\'',\n    '<': ',',\n    '>': '.',\n    '?': '/',\n    '|': '\\\\'\n  };\n  /**\n   * this is a list of special strings you can use to map\n   * to modifier keys when you specify your keyboard shortcuts\n   *\n   * @type {Object}\n   */\n\n  var _SPECIAL_ALIASES = {\n    'option': 'alt',\n    'command': 'meta',\n    'return': 'enter',\n    'escape': 'esc',\n    'plus': '+',\n    'mod': /Mac|iPod|iPhone|iPad/.test(navigator.platform) ? 'meta' : 'ctrl'\n  };\n  /**\n   * variable to store the flipped version of _MAP from above\n   * needed to check if we should use keypress or not when no action\n   * is specified\n   *\n   * @type {Object|undefined}\n   */\n\n  var _REVERSE_MAP;\n  /**\n   * loop through the f keys, f1 to f19 and add them to the map\n   * programatically\n   */\n\n\n  for (var i = 1; i < 20; ++i) {\n    _MAP[111 + i] = 'f' + i;\n  }\n  /**\n   * loop through to map numbers on the numeric keypad\n   */\n\n\n  for (i = 0; i <= 9; ++i) {\n    // This needs to use a string cause otherwise since 0 is falsey\n    // mousetrap will never fire for numpad 0 pressed as part of a keydown\n    // event.\n    //\n    // @see https://github.com/ccampbell/mousetrap/pull/258\n    _MAP[i + 96] = i.toString();\n  }\n  /**\n   * cross browser add event method\n   *\n   * @param {Element|HTMLDocument} object\n   * @param {string} type\n   * @param {Function} callback\n   * @returns void\n   */\n\n\n  function _addEvent(object, type, callback) {\n    if (object.addEventListener) {\n      object.addEventListener(type, callback, false);\n      return;\n    }\n\n    object.attachEvent('on' + type, callback);\n  }\n  /**\n   * takes the event and returns the key character\n   *\n   * @param {Event} e\n   * @return {string}\n   */\n\n\n  function _characterFromEvent(e) {\n    // for keypress events we should return the character as is\n    if (e.type == 'keypress') {\n      var character = String.fromCharCode(e.which); // if the shift key is not pressed then it is safe to assume\n      // that we want the character to be lowercase.  this means if\n      // you accidentally have caps lock on then your key bindings\n      // will continue to work\n      //\n      // the only side effect that might not be desired is if you\n      // bind something like 'A' cause you want to trigger an\n      // event when capital A is pressed caps lock will no longer\n      // trigger the event.  shift+a will though.\n\n      if (!e.shiftKey) {\n        character = character.toLowerCase();\n      }\n\n      return character;\n    } // for non keypress events the special maps are needed\n\n\n    if (_MAP[e.which]) {\n      return _MAP[e.which];\n    }\n\n    if (_KEYCODE_MAP[e.which]) {\n      return _KEYCODE_MAP[e.which];\n    } // if it is not in the special map\n    // with keydown and keyup events the character seems to always\n    // come in as an uppercase character whether you are pressing shift\n    // or not.  we should make sure it is always lowercase for comparisons\n\n\n    return String.fromCharCode(e.which).toLowerCase();\n  }\n  /**\n   * checks if two arrays are equal\n   *\n   * @param {Array} modifiers1\n   * @param {Array} modifiers2\n   * @returns {boolean}\n   */\n\n\n  function _modifiersMatch(modifiers1, modifiers2) {\n    return modifiers1.sort().join(',') === modifiers2.sort().join(',');\n  }\n  /**\n   * takes a key event and figures out what the modifiers are\n   *\n   * @param {Event} e\n   * @returns {Array}\n   */\n\n\n  function _eventModifiers(e) {\n    var modifiers = [];\n\n    if (e.shiftKey) {\n      modifiers.push('shift');\n    }\n\n    if (e.altKey) {\n      modifiers.push('alt');\n    }\n\n    if (e.ctrlKey) {\n      modifiers.push('ctrl');\n    }\n\n    if (e.metaKey) {\n      modifiers.push('meta');\n    }\n\n    return modifiers;\n  }\n  /**\n   * prevents default for this event\n   *\n   * @param {Event} e\n   * @returns void\n   */\n\n\n  function _preventDefault(e) {\n    if (e.preventDefault) {\n      e.preventDefault();\n      return;\n    }\n\n    e.returnValue = false;\n  }\n  /**\n   * stops propogation for this event\n   *\n   * @param {Event} e\n   * @returns void\n   */\n\n\n  function _stopPropagation(e) {\n    if (e.stopPropagation) {\n      e.stopPropagation();\n      return;\n    }\n\n    e.cancelBubble = true;\n  }\n  /**\n   * determines if the keycode specified is a modifier key or not\n   *\n   * @param {string} key\n   * @returns {boolean}\n   */\n\n\n  function _isModifier(key) {\n    return key == 'shift' || key == 'ctrl' || key == 'alt' || key == 'meta';\n  }\n  /**\n   * reverses the map lookup so that we can look for specific keys\n   * to see what can and can't use keypress\n   *\n   * @return {Object}\n   */\n\n\n  function _getReverseMap() {\n    if (!_REVERSE_MAP) {\n      _REVERSE_MAP = {};\n\n      for (var key in _MAP) {\n        // pull out the numeric keypad from here cause keypress should\n        // be able to detect the keys from the character\n        if (key > 95 && key < 112) {\n          continue;\n        }\n\n        if (_MAP.hasOwnProperty(key)) {\n          _REVERSE_MAP[_MAP[key]] = key;\n        }\n      }\n    }\n\n    return _REVERSE_MAP;\n  }\n  /**\n   * picks the best action based on the key combination\n   *\n   * @param {string} key - character for key\n   * @param {Array} modifiers\n   * @param {string=} action passed in\n   */\n\n\n  function _pickBestAction(key, modifiers, action) {\n    // if no action was picked in we should try to pick the one\n    // that we think would work best for this key\n    if (!action) {\n      action = _getReverseMap()[key] ? 'keydown' : 'keypress';\n    } // modifier keys don't work as expected with keypress,\n    // switch to keydown\n\n\n    if (action == 'keypress' && modifiers.length) {\n      action = 'keydown';\n    }\n\n    return action;\n  }\n  /**\n   * Converts from a string key combination to an array\n   *\n   * @param  {string} combination like \"command+shift+l\"\n   * @return {Array}\n   */\n\n\n  function _keysFromString(combination) {\n    if (combination === '+') {\n      return ['+'];\n    }\n\n    combination = combination.replace(/\\+{2}/g, '+plus');\n    return combination.split('+');\n  }\n  /**\n   * Gets info for a specific key combination\n   *\n   * @param  {string} combination key combination (\"command+s\" or \"a\" or \"*\")\n   * @param  {string=} action\n   * @returns {Object}\n   */\n\n\n  function _getKeyInfo(combination, action) {\n    var keys;\n    var key;\n    var i;\n    var modifiers = []; // take the keys from this pattern and figure out what the actual\n    // pattern is all about\n\n    keys = _keysFromString(combination);\n\n    for (i = 0; i < keys.length; ++i) {\n      key = keys[i]; // normalize key names\n\n      if (_SPECIAL_ALIASES[key]) {\n        key = _SPECIAL_ALIASES[key];\n      } // if this is not a keypress event then we should\n      // be smart about using shift keys\n      // this will only work for US keyboards however\n\n\n      if (action && action != 'keypress' && _SHIFT_MAP[key]) {\n        key = _SHIFT_MAP[key];\n        modifiers.push('shift');\n      } // if this key is a modifier then add it to the list of modifiers\n\n\n      if (_isModifier(key)) {\n        modifiers.push(key);\n      }\n    } // depending on what the key combination is\n    // we will try to pick the best event for it\n\n\n    action = _pickBestAction(key, modifiers, action);\n    return {\n      key: key,\n      modifiers: modifiers,\n      action: action\n    };\n  }\n\n  function _belongsTo(element, ancestor) {\n    if (element === null || element === document) {\n      return false;\n    }\n\n    if (element === ancestor) {\n      return true;\n    }\n\n    return _belongsTo(element.parentNode, ancestor);\n  }\n\n  function Mousetrap(targetElement) {\n    var self = this;\n    targetElement = targetElement || document;\n\n    if (!(self instanceof Mousetrap)) {\n      return new Mousetrap(targetElement);\n    }\n    /**\n     * element to attach key events to\n     *\n     * @type {Element}\n     */\n\n\n    self.target = targetElement;\n    /**\n     * a list of all the callbacks setup via Mousetrap.bind()\n     *\n     * @type {Object}\n     */\n\n    self._callbacks = {};\n    /**\n     * direct map of string combinations to callbacks used for trigger()\n     *\n     * @type {Object}\n     */\n\n    self._directMap = {};\n    /**\n     * keeps track of what level each sequence is at since multiple\n     * sequences can start out with the same sequence\n     *\n     * @type {Object}\n     */\n\n    var _sequenceLevels = {};\n    /**\n     * variable to store the setTimeout call\n     *\n     * @type {null|number}\n     */\n\n    var _resetTimer;\n    /**\n     * temporary state where we will ignore the next keyup\n     *\n     * @type {boolean|string}\n     */\n\n\n    var _ignoreNextKeyup = false;\n    /**\n     * temporary state where we will ignore the next keypress\n     *\n     * @type {boolean}\n     */\n\n    var _ignoreNextKeypress = false;\n    /**\n     * are we currently inside of a sequence?\n     * type of action (\"keyup\" or \"keydown\" or \"keypress\") or false\n     *\n     * @type {boolean|string}\n     */\n\n    var _nextExpectedAction = false;\n    /**\n     * resets all sequence counters except for the ones passed in\n     *\n     * @param {Object} doNotReset\n     * @returns void\n     */\n\n    function _resetSequences(doNotReset) {\n      doNotReset = doNotReset || {};\n      var activeSequences = false,\n          key;\n\n      for (key in _sequenceLevels) {\n        if (doNotReset[key]) {\n          activeSequences = true;\n          continue;\n        }\n\n        _sequenceLevels[key] = 0;\n      }\n\n      if (!activeSequences) {\n        _nextExpectedAction = false;\n      }\n    }\n    /**\n     * finds all callbacks that match based on the keycode, modifiers,\n     * and action\n     *\n     * @param {string} character\n     * @param {Array} modifiers\n     * @param {Event|Object} e\n     * @param {string=} sequenceName - name of the sequence we are looking for\n     * @param {string=} combination\n     * @param {number=} level\n     * @returns {Array}\n     */\n\n\n    function _getMatches(character, modifiers, e, sequenceName, combination, level) {\n      var i;\n      var callback;\n      var matches = [];\n      var action = e.type; // if there are no events related to this keycode\n\n      if (!self._callbacks[character]) {\n        return [];\n      } // if a modifier key is coming up on its own we should allow it\n\n\n      if (action == 'keyup' && _isModifier(character)) {\n        modifiers = [character];\n      } // loop through all callbacks for the key that was pressed\n      // and see if any of them match\n\n\n      for (i = 0; i < self._callbacks[character].length; ++i) {\n        callback = self._callbacks[character][i]; // if a sequence name is not specified, but this is a sequence at\n        // the wrong level then move onto the next match\n\n        if (!sequenceName && callback.seq && _sequenceLevels[callback.seq] != callback.level) {\n          continue;\n        } // if the action we are looking for doesn't match the action we got\n        // then we should keep going\n\n\n        if (action != callback.action) {\n          continue;\n        } // if this is a keypress event and the meta key and control key\n        // are not pressed that means that we need to only look at the\n        // character, otherwise check the modifiers as well\n        //\n        // chrome will not fire a keypress if meta or control is down\n        // safari will fire a keypress if meta or meta+shift is down\n        // firefox will fire a keypress if meta or control is down\n\n\n        if (action == 'keypress' && !e.metaKey && !e.ctrlKey || _modifiersMatch(modifiers, callback.modifiers)) {\n          // when you bind a combination or sequence a second time it\n          // should overwrite the first one.  if a sequenceName or\n          // combination is specified in this call it does just that\n          //\n          // @todo make deleting its own method?\n          var deleteCombo = !sequenceName && callback.combo == combination;\n          var deleteSequence = sequenceName && callback.seq == sequenceName && callback.level == level;\n\n          if (deleteCombo || deleteSequence) {\n            self._callbacks[character].splice(i, 1);\n          }\n\n          matches.push(callback);\n        }\n      }\n\n      return matches;\n    }\n    /**\n     * actually calls the callback function\n     *\n     * if your callback function returns false this will use the jquery\n     * convention - prevent default and stop propogation on the event\n     *\n     * @param {Function} callback\n     * @param {Event} e\n     * @returns void\n     */\n\n\n    function _fireCallback(callback, e, combo, sequence) {\n      // if this event should not happen stop here\n      if (self.stopCallback(e, e.target || e.srcElement, combo, sequence)) {\n        return;\n      }\n\n      if (callback(e, combo) === false) {\n        _preventDefault(e);\n\n        _stopPropagation(e);\n      }\n    }\n    /**\n     * handles a character key event\n     *\n     * @param {string} character\n     * @param {Array} modifiers\n     * @param {Event} e\n     * @returns void\n     */\n\n\n    self._handleKey = function (character, modifiers, e) {\n      var callbacks = _getMatches(character, modifiers, e);\n\n      var i;\n      var doNotReset = {};\n      var maxLevel = 0;\n      var processedSequenceCallback = false; // Calculate the maxLevel for sequences so we can only execute the longest callback sequence\n\n      for (i = 0; i < callbacks.length; ++i) {\n        if (callbacks[i].seq) {\n          maxLevel = Math.max(maxLevel, callbacks[i].level);\n        }\n      } // loop through matching callbacks for this key event\n\n\n      for (i = 0; i < callbacks.length; ++i) {\n        // fire for all sequence callbacks\n        // this is because if for example you have multiple sequences\n        // bound such as \"g i\" and \"g t\" they both need to fire the\n        // callback for matching g cause otherwise you can only ever\n        // match the first one\n        if (callbacks[i].seq) {\n          // only fire callbacks for the maxLevel to prevent\n          // subsequences from also firing\n          //\n          // for example 'a option b' should not cause 'option b' to fire\n          // even though 'option b' is part of the other sequence\n          //\n          // any sequences that do not match here will be discarded\n          // below by the _resetSequences call\n          if (callbacks[i].level != maxLevel) {\n            continue;\n          }\n\n          processedSequenceCallback = true; // keep a list of which sequences were matches for later\n\n          doNotReset[callbacks[i].seq] = 1;\n\n          _fireCallback(callbacks[i].callback, e, callbacks[i].combo, callbacks[i].seq);\n\n          continue;\n        } // if there were no sequence matches but we are still here\n        // that means this is a regular match so we should fire that\n\n\n        if (!processedSequenceCallback) {\n          _fireCallback(callbacks[i].callback, e, callbacks[i].combo);\n        }\n      } // if the key you pressed matches the type of sequence without\n      // being a modifier (ie \"keyup\" or \"keypress\") then we should\n      // reset all sequences that were not matched by this event\n      //\n      // this is so, for example, if you have the sequence \"h a t\" and you\n      // type \"h e a r t\" it does not match.  in this case the \"e\" will\n      // cause the sequence to reset\n      //\n      // modifier keys are ignored because you can have a sequence\n      // that contains modifiers such as \"enter ctrl+space\" and in most\n      // cases the modifier key will be pressed before the next key\n      //\n      // also if you have a sequence such as \"ctrl+b a\" then pressing the\n      // \"b\" key will trigger a \"keypress\" and a \"keydown\"\n      //\n      // the \"keydown\" is expected when there is a modifier, but the\n      // \"keypress\" ends up matching the _nextExpectedAction since it occurs\n      // after and that causes the sequence to reset\n      //\n      // we ignore keypresses in a sequence that directly follow a keydown\n      // for the same character\n\n\n      var ignoreThisKeypress = e.type == 'keypress' && _ignoreNextKeypress;\n\n      if (e.type == _nextExpectedAction && !_isModifier(character) && !ignoreThisKeypress) {\n        _resetSequences(doNotReset);\n      }\n\n      _ignoreNextKeypress = processedSequenceCallback && e.type == 'keydown';\n    };\n    /**\n     * handles a keydown event\n     *\n     * @param {Event} e\n     * @returns void\n     */\n\n\n    function _handleKeyEvent(e) {\n      // normalize e.which for key events\n      // @see http://stackoverflow.com/questions/4285627/javascript-keycode-vs-charcode-utter-confusion\n      if (typeof e.which !== 'number') {\n        e.which = e.keyCode;\n      }\n\n      var character = _characterFromEvent(e); // no character found then stop\n\n\n      if (!character) {\n        return;\n      } // need to use === for the character check because the character can be 0\n\n\n      if (e.type == 'keyup' && _ignoreNextKeyup === character) {\n        _ignoreNextKeyup = false;\n        return;\n      }\n\n      self.handleKey(character, _eventModifiers(e), e);\n    }\n    /**\n     * called to set a 1 second timeout on the specified sequence\n     *\n     * this is so after each key press in the sequence you have 1 second\n     * to press the next key before you have to start over\n     *\n     * @returns void\n     */\n\n\n    function _resetSequenceTimer() {\n      clearTimeout(_resetTimer);\n      _resetTimer = setTimeout(_resetSequences, 1000);\n    }\n    /**\n     * binds a key sequence to an event\n     *\n     * @param {string} combo - combo specified in bind call\n     * @param {Array} keys\n     * @param {Function} callback\n     * @param {string=} action\n     * @returns void\n     */\n\n\n    function _bindSequence(combo, keys, callback, action) {\n      // start off by adding a sequence level record for this combination\n      // and setting the level to 0\n      _sequenceLevels[combo] = 0;\n      /**\n       * callback to increase the sequence level for this sequence and reset\n       * all other sequences that were active\n       *\n       * @param {string} nextAction\n       * @returns {Function}\n       */\n\n      function _increaseSequence(nextAction) {\n        return function () {\n          _nextExpectedAction = nextAction;\n          ++_sequenceLevels[combo];\n\n          _resetSequenceTimer();\n        };\n      }\n      /**\n       * wraps the specified callback inside of another function in order\n       * to reset all sequence counters as soon as this sequence is done\n       *\n       * @param {Event} e\n       * @returns void\n       */\n\n\n      function _callbackAndReset(e) {\n        _fireCallback(callback, e, combo); // we should ignore the next key up if the action is key down\n        // or keypress.  this is so if you finish a sequence and\n        // release the key the final key will not trigger a keyup\n\n\n        if (action !== 'keyup') {\n          _ignoreNextKeyup = _characterFromEvent(e);\n        } // weird race condition if a sequence ends with the key\n        // another sequence begins with\n\n\n        setTimeout(_resetSequences, 10);\n      } // loop through keys one at a time and bind the appropriate callback\n      // function.  for any key leading up to the final one it should\n      // increase the sequence. after the final, it should reset all sequences\n      //\n      // if an action is specified in the original bind call then that will\n      // be used throughout.  otherwise we will pass the action that the\n      // next key in the sequence should match.  this allows a sequence\n      // to mix and match keypress and keydown events depending on which\n      // ones are better suited to the key provided\n\n\n      for (var i = 0; i < keys.length; ++i) {\n        var isFinal = i + 1 === keys.length;\n        var wrappedCallback = isFinal ? _callbackAndReset : _increaseSequence(action || _getKeyInfo(keys[i + 1]).action);\n\n        _bindSingle(keys[i], wrappedCallback, action, combo, i);\n      }\n    }\n    /**\n     * binds a single keyboard combination\n     *\n     * @param {string} combination\n     * @param {Function} callback\n     * @param {string=} action\n     * @param {string=} sequenceName - name of sequence if part of sequence\n     * @param {number=} level - what part of the sequence the command is\n     * @returns void\n     */\n\n\n    function _bindSingle(combination, callback, action, sequenceName, level) {\n      // store a direct mapped reference for use with Mousetrap.trigger\n      self._directMap[combination + ':' + action] = callback; // make sure multiple spaces in a row become a single space\n\n      combination = combination.replace(/\\s+/g, ' ');\n      var sequence = combination.split(' ');\n      var info; // if this pattern is a sequence of keys then run through this method\n      // to reprocess each pattern one key at a time\n\n      if (sequence.length > 1) {\n        _bindSequence(combination, sequence, callback, action);\n\n        return;\n      }\n\n      info = _getKeyInfo(combination, action); // make sure to initialize array if this is the first time\n      // a callback is added for this key\n\n      self._callbacks[info.key] = self._callbacks[info.key] || []; // remove an existing match if there is one\n\n      _getMatches(info.key, info.modifiers, {\n        type: info.action\n      }, sequenceName, combination, level); // add this call back to the array\n      // if it is a sequence put it at the beginning\n      // if not put it at the end\n      //\n      // this is important because the way these are processed expects\n      // the sequence ones to come first\n\n\n      self._callbacks[info.key][sequenceName ? 'unshift' : 'push']({\n        callback: callback,\n        modifiers: info.modifiers,\n        action: info.action,\n        seq: sequenceName,\n        level: level,\n        combo: combination\n      });\n    }\n    /**\n     * binds multiple combinations to the same callback\n     *\n     * @param {Array} combinations\n     * @param {Function} callback\n     * @param {string|undefined} action\n     * @returns void\n     */\n\n\n    self._bindMultiple = function (combinations, callback, action) {\n      for (var i = 0; i < combinations.length; ++i) {\n        _bindSingle(combinations[i], callback, action);\n      }\n    }; // start!\n\n\n    _addEvent(targetElement, 'keypress', _handleKeyEvent);\n\n    _addEvent(targetElement, 'keydown', _handleKeyEvent);\n\n    _addEvent(targetElement, 'keyup', _handleKeyEvent);\n  }\n  /**\n   * binds an event to mousetrap\n   *\n   * can be a single key, a combination of keys separated with +,\n   * an array of keys, or a sequence of keys separated by spaces\n   *\n   * be sure to list the modifier keys first to make sure that the\n   * correct key ends up getting bound (the last key in the pattern)\n   *\n   * @param {string|Array} keys\n   * @param {Function} callback\n   * @param {string=} action - 'keypress', 'keydown', or 'keyup'\n   * @returns void\n   */\n\n\n  Mousetrap.prototype.bind = function (keys, callback, action) {\n    var self = this;\n    keys = keys instanceof Array ? keys : [keys];\n\n    self._bindMultiple.call(self, keys, callback, action);\n\n    return self;\n  };\n  /**\n   * unbinds an event to mousetrap\n   *\n   * the unbinding sets the callback function of the specified key combo\n   * to an empty function and deletes the corresponding key in the\n   * _directMap dict.\n   *\n   * TODO: actually remove this from the _callbacks dictionary instead\n   * of binding an empty function\n   *\n   * the keycombo+action has to be exactly the same as\n   * it was defined in the bind method\n   *\n   * @param {string|Array} keys\n   * @param {string} action\n   * @returns void\n   */\n\n\n  Mousetrap.prototype.unbind = function (keys, action) {\n    var self = this;\n    return self.bind.call(self, keys, function () {}, action);\n  };\n  /**\n   * triggers an event that has already been bound\n   *\n   * @param {string} keys\n   * @param {string=} action\n   * @returns void\n   */\n\n\n  Mousetrap.prototype.trigger = function (keys, action) {\n    var self = this;\n\n    if (self._directMap[keys + ':' + action]) {\n      self._directMap[keys + ':' + action]({}, keys);\n    }\n\n    return self;\n  };\n  /**\n   * resets the library back to its initial state.  this is useful\n   * if you want to clear out the current keyboard shortcuts and bind\n   * new ones - for example if you switch to another page\n   *\n   * @returns void\n   */\n\n\n  Mousetrap.prototype.reset = function () {\n    var self = this;\n    self._callbacks = {};\n    self._directMap = {};\n    return self;\n  };\n  /**\n   * should we stop this event before firing off callbacks\n   *\n   * @param {Event} e\n   * @param {Element} element\n   * @return {boolean}\n   */\n\n\n  Mousetrap.prototype.stopCallback = function (e, element) {\n    var self = this; // if the element has the class \"mousetrap\" then no need to stop\n\n    if ((' ' + element.className + ' ').indexOf(' mousetrap ') > -1) {\n      return false;\n    }\n\n    if (_belongsTo(element, self.target)) {\n      return false;\n    } // Events originating from a shadow DOM are re-targetted and `e.target` is the shadow host,\n    // not the initial event target in the shadow tree. Note that not all events cross the\n    // shadow boundary.\n    // For shadow trees with `mode: 'open'`, the initial event target is the first element in\n    // the event’s composed path. For shadow trees with `mode: 'closed'`, the initial event\n    // target cannot be obtained.\n\n\n    if ('composedPath' in e && typeof e.composedPath === 'function') {\n      // For open shadow trees, update `element` so that the following check works.\n      var initialEventTarget = e.composedPath()[0];\n\n      if (initialEventTarget !== e.target) {\n        element = initialEventTarget;\n      }\n    } // stop for input, select, and textarea\n\n\n    return element.tagName == 'INPUT' || element.tagName == 'SELECT' || element.tagName == 'TEXTAREA' || element.isContentEditable;\n  };\n  /**\n   * exposes _handleKey publicly so it can be overwritten by extensions\n   */\n\n\n  Mousetrap.prototype.handleKey = function () {\n    var self = this;\n    return self._handleKey.apply(self, arguments);\n  };\n  /**\n   * allow custom key mappings\n   */\n\n\n  Mousetrap.addKeycodes = function (object) {\n    for (var key in object) {\n      if (object.hasOwnProperty(key)) {\n        _MAP[key] = object[key];\n      }\n    }\n\n    _REVERSE_MAP = null;\n  };\n  /**\n   * Init the global mousetrap functions\n   *\n   * This method is needed to allow the global mousetrap functions to work\n   * now that mousetrap is a constructor function.\n   */\n\n\n  Mousetrap.init = function () {\n    var documentMousetrap = Mousetrap(document);\n\n    for (var method in documentMousetrap) {\n      if (method.charAt(0) !== '_') {\n        Mousetrap[method] = function (method) {\n          return function () {\n            return documentMousetrap[method].apply(documentMousetrap, arguments);\n          };\n        }(method);\n      }\n    }\n  };\n\n  Mousetrap.init(); // expose mousetrap to the global object\n\n  window.Mousetrap = Mousetrap; // expose as a common js module\n\n  if (typeof module !== 'undefined' && module.exports) {\n    module.exports = Mousetrap;\n  } // expose mousetrap as an AMD module\n\n\n  if (typeof define === 'function' && define.amd) {\n    define(function () {\n      return Mousetrap;\n    });\n  }\n})(typeof window !== 'undefined' ? window : null, typeof window !== 'undefined' ? document : null);"],"sourceRoot":""}